# -*- coding: utf-8 -*-
"""Heat_equation_par_Moussa_Sow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xZx50VLQxwW9jX_wB6gh6bkz96q_msa
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import ipywidgets as widgets
from IPython.display import display, HTML, clear_output

# ==============================================================================
# LE C≈íUR DU SOLVEUR : DIFF√âRENCES FINIES EXPLICITES (FTCS)
# ==============================================================================

def solve_heat_equation_1D(L, T_end, nx, alpha, initial_temp_func,
                           bc_left_type, bc_left_val, bc_right_type, bc_right_val,
                           dt_factor=0.45):
    """
    R√©sout l'√©quation de la chaleur 1D (‚àÇu/‚àÇt = Œ± * ‚àÇ¬≤u/‚àÇx¬≤) en utilisant la m√©thode
    des Diff√©rences Finies Explicite (FTCS).

    Retourne: x (positions), t (temps), u (matrice de temp√©rature) et r (param√®tre de stabilit√©)
    """

    # 1. Discr√©tisation Spatiale
    dx = L / (nx - 1)
    x = np.linspace(0, L, nx)

    # 2. Discr√©tisation Temporelle et Stabilit√©
    # Crit√®re de stabilit√© explicite : dt <= dx¬≤ / (2 * alpha)
    dt_stable_limit = (dx**2) / (2 * alpha)
    dt = dt_factor * dt_stable_limit

    nt = int(T_end / dt) + 1
    t = np.linspace(0, T_end, nt)

    # Param√®tre de Fourier (r)
    r = alpha * dt / (dx**2)

    print(f"Discr√©tisation: dx={dx:.4f}, dt={dt:.6f} (nt={nt}, r={r:.3f})")
    if r > 0.5:
        print("üö® AVERTISSEMENT: r > 0.5. La simulation Explicite sera instable (divergence).")

    # 3. Initialisation de la Temp√©rature
    u = np.zeros((nt, nx))
    u[0, :] = initial_temp_func(x)

    # 4. Boucle de Temps (Formule FTCS)
    for k in range(nt - 1):
        u_prev = u[k, :]
        u_next = u[k+1, :]

        # Calcul des points int√©rieurs (indices 1 √† nx-2)
        # Formule : u_i^{k+1} = u_i^k + r * (u_{i+1}^k - 2*u_i^k + u_{i-1}^k)
        u_next[1:nx-1] = u_prev[1:nx-1] + r * (u_prev[2:nx] - 2 * u_prev[1:nx-1] + u_prev[0:nx-2])

        # 5. Application des Conditions aux Limites (CL)

        # CL Gauche (x=0)
        if bc_left_type == 'Dirichlet':
            u_next[0] = bc_left_val
        elif bc_left_type == 'Neumann':
            # Approximation Diff√©rence Avant : (u[1] - u[0]) / dx = Flux
            u_next[0] = u_next[1] - (bc_left_val * dx) / alpha

        # CL Droite (x=L)
        if bc_right_type == 'Dirichlet':
            u_next[nx - 1] = bc_right_val
        elif bc_right_type == 'Neumann':
            # Approximation Diff√©rence Arri√®re : (u[nx-1] - u[nx-2]) / dx = Flux
            u_next[nx - 1] = u_next[nx - 2] + (bc_right_val * dx) / alpha

    return x, t, u, r

# ==============================================================================
# INTERFACE ET VISUALISATION (IPYWIDGETS et MATPLOTLIB)
# ==============================================================================

def create_heat_simulator_ui():

    # Variables pour le stockage des r√©sultats (Locales √† create_heat_simulator_ui)
    simulation_results = None
    simulation_data_ready = False

    # --- Widgets d'entr√©e ---
    L_widget = widgets.FloatSlider(value=1.0, min=0.1, max=5.0, step=0.1, description='Longueur L (m):')
    T_end_widget = widgets.FloatSlider(value=1.0, min=0.1, max=10.0, step=0.1, description='Temps total T_end (s):')
    nx_widget = widgets.IntSlider(value=50, min=20, max=200, step=10, description='Points spatiaux nx:')
    alpha_widget = widgets.FloatSlider(value=0.01, min=0.001, max=0.1, step=0.001, readout_format='.4f', description='Diffusivit√© Œ± (m¬≤/s):')
    dt_factor_widget = widgets.FloatSlider(value=0.45, min=0.1, max=0.5, step=0.01, readout_format='.2f', description='Facteur Stabilit√© (<0.5):')

    # Fonctions de temp√©rature initiale
    def get_initial_temp_options(L_val):
        return {
            'Sinusoidal (sin(pi*x))': lambda x: np.sin(np.pi * x),
            'Gaussian (Pic Central)': lambda x: np.exp(-(x - L_val/2)**2 / 0.05),
            'Point Chaud (20% √† 30% de L)': lambda x: np.where((x > L_val*0.2) & (x < L_val*0.3), 1.0, 0.0),
            'Temp√©rature Constante (0.5)': lambda x: 0.5
        }

    initial_temp_options = get_initial_temp_options(L_widget.value)
    initial_temp_names = list(initial_temp_options.keys())
    initial_temp_widget = widgets.Dropdown(options=initial_temp_names, value=initial_temp_names[0], description='Temp. Initiale:')

    # Conditions aux limites
    bc_left_type_widget = widgets.Dropdown(options=['Dirichlet', 'Neumann'], value='Dirichlet', description='CL Gauche (x=0):')
    bc_left_val_widget = widgets.FloatText(value=0.0, description='Valeur CL G (T ou Flux):')
    bc_right_type_widget = widgets.Dropdown(options=['Dirichlet', 'Neumann'], value='Dirichlet', description='CL Droite (x=L):')
    bc_right_val_widget = widgets.FloatText(value=0.0, description='Valeur CL D (T ou Flux):')

    # --- Boutons et Sorties ---
    run_button = widgets.Button(description='Ex√©cuter la Simulation', button_style='success')
    animate_button = widgets.Button(description='Animer l\'√âvolution', button_style='warning', disabled=True)
    get_data_button = widgets.Button(description='Afficher les Donn√©es', button_style='primary', disabled=True)

    output_console = widgets.Output()
    animation_output = widgets.Output() # Sortie d√©di√©e pour l'animation

    # --- Fonctions de Callback ---

    def on_run_clicked(b):
        # Utilisation de nonlocal pour modifier les variables du scope parent
        nonlocal simulation_results, simulation_data_ready

        # R√©cup√©ration de la fonction de temp√©rature initiale bas√©e sur L actuel
        current_initial_temp_options = get_initial_temp_options(L_widget.value)
        selected_temp_func = current_initial_temp_options[initial_temp_widget.value]

        with output_console:
            clear_output(wait=True)
            print("üöÄ D√©but de la simulation...")

        try:
            # Appel du solveur FTCS
            x, t, u, r = solve_heat_equation_1D(
                L=L_widget.value,
                T_end=T_end_widget.value,
                nx=nx_widget.value,
                alpha=alpha_widget.value,
                initial_temp_func=selected_temp_func,
                bc_left_type=bc_left_type_widget.value,
                bc_left_val=bc_left_val_widget.value,
                bc_right_type=bc_right_type_widget.value,
                bc_right_val=bc_right_val_widget.value,
                dt_factor=dt_factor_widget.value
            )

            simulation_results = {'x': x, 't': t, 'u': u, 'r': r}
            simulation_data_ready = True

            animate_button.disabled = False
            get_data_button.disabled = False

            print("‚úÖ Simulation termin√©e avec succ√®s.")
            print(f"   Param√®tre r de Fourier : {r:.4f}")

        except Exception as e:
            simulation_data_ready = False
            print(f"‚ùå Erreur lors de l'ex√©cution : {e}")


    def on_animate_clicked(b):
        if not simulation_data_ready:
            with output_console:
                print("Veuillez d'abord ex√©cuter la simulation.")
            return

        x, t, u = simulation_results['x'], simulation_results['t'], simulation_results['u']

        # Configuration de l'animation
        fig, ax = plt.subplots(figsize=(10, 6))
        line, = ax.plot(x, u[0, :], color='blue')
        ax.set_title('√âvolution de la Temp√©rature (M√©thode Explicite)')
        ax.set_xlabel('Position x (m)')
        ax.set_ylabel('Temp√©rature u')
        ax.set_xlim(0, L_widget.value)
        ax.set_ylim(u.min() - 0.1, u.max() + 0.1)
        ax.grid(True)

        # Contr√¥le de la fr√©quence de l'animation
        max_frames = 200
        frame_skip = max(1, len(t) // max_frames)

        def update(frame_idx):
            time_step = frame_idx * frame_skip
            line.set_ydata(u[time_step, :])
            ax.set_title(f'√âvolution de la Temp√©rature (t = {t[time_step]:.4f} s)')
            return line,

        anim = FuncAnimation(fig, update, frames=range(0, len(t), frame_skip),
                             interval=50, blit=True, repeat=False)

        with animation_output:
            clear_output(wait=True)
            # Affichage de l'animation en HTML pour Colab/Jupyter
            display(HTML(anim.to_jshtml(default_mode='once')))
            plt.close(fig)


    def on_get_data_clicked(b):
        if not simulation_data_ready:
            with output_console:
                print("Veuillez d'abord ex√©cuter la simulation.")
            return

        data = simulation_results

        with output_console:
            clear_output(wait=True)
            print("--- Donn√©es de la Simulation Num√©rique ---")
            print(f"  M√©thode : Diff√©rences Finies Explicites (FTCS)")
            print(f"  Param√®tre de Fourier (r) : {data['r']:.4f}")
            print(f"  Points spatiaux (nx) : {len(data['x'])}, Pas de temps (nt) : {len(data['t'])}")
            print("-" * 40)
            print(f"  Exemple des 5 premi√®res positions x: {data['x'][:5]}")
            print(f"  Exemple des 5 premiers pas de temps: {data['t'][:5]}")
            print("-" * 40)

            # Rendre les donn√©es accessibles globalement pour l'analyse
            global simulation_data
            simulation_data = data
            print("\nüìö Les donn√©es compl√®tes sont stock√©es dans la variable `simulation_data` pour analyse.")
            print("Ex√©cutez une nouvelle cellule pour tracer des courbes sp√©cifiques, par exemple :")
            print("plt.plot(simulation_data['x'], simulation_data['u'][0, :], label='Initial')")


    # Connexion des callbacks aux boutons
    run_button.on_click(on_run_clicked)
    animate_button.on_click(on_animate_clicked)
    get_data_button.on_click(on_get_data_clicked)

    # Layout de l'interface
    param_layout_1 = widgets.VBox([L_widget, T_end_widget, nx_widget, alpha_widget, dt_factor_widget])
    param_layout_2 = widgets.VBox([initial_temp_widget, bc_left_type_widget, bc_left_val_widget, bc_right_type_widget, bc_right_val_widget])

    main_layout = widgets.VBox([
        widgets.HTML("<h2 style='text-align:center; color:#1e88e5;'>üå°Ô∏è Solveur 1D de l'√âquation de la Chaleur (FTCS Manuel) üå°Ô∏è</h2>"),
        widgets.HBox([param_layout_1, param_layout_2]),
        widgets.HBox([run_button, animate_button, get_data_button]),
        output_console,
        animation_output
    ])

    display(main_layout)

# ==============================================================================
# LANCER L'INTERFACE DE SIMULATION
# ==============================================================================
create_heat_simulator_ui()

# CODE √Ä EX√âCUTER DANS UNE NOUVELLE CELLULE APR√àS LA SIMULATION
if 'simulation_data' in globals():
    x = simulation_data['x']
    t = simulation_data['t']
    u = simulation_data['u']

    # --- Profils de Temp√©rature √† diff√©rents instants (Courbes vs Position) ---
    plt.figure(figsize=(10, 6))
    plt.plot(x, u[0, :], label=f'Initial (t={t[0]:.2f} s)', linestyle='--', color='gray')
    plt.plot(x, u[len(t)//3, :], label=f't={t[len(t)//3]:.2f} s')
    plt.plot(x, u[-1, :], label=f'Final (t={t[-1]:.2f} s)', linewidth=3, color='red')

    plt.title('Profils de Temp√©rature le long de la Barre')
    plt.xlabel('Position x (m)')
    plt.ylabel('Temp√©rature u')
    plt.legend()
    plt.grid(True)
    plt.show()

    # --- √âvolution de la Temp√©rature √† un point (Courbe vs Temps) ---
    mid_point_idx = len(x) // 2
    plt.figure(figsize=(10, 6))
    plt.plot(t, u[:, mid_point_idx], label=f'Temp√©rature au centre (x={x[mid_point_idx]:.2f} m)')

    plt.title('√âvolution de la Temp√©rature en fonction du Temps')
    plt.xlabel('Temps (s)')
    plt.ylabel('Temp√©rature u')
    plt.legend()
    plt.grid(True)
    plt.show()

else:
    print("Veuillez d'abord ex√©cuter la simulation et cliquer sur 'Afficher les Donn√©es' dans l'interface.")